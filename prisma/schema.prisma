generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  ADMIN
}

enum IpAccessRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

model Tenant {
  id        String   @id @default(uuid()) @db.Uuid
  slug      String   @unique
  name      String
  createdAt DateTime @default(now())

  users            User[]
  allowedIps       AllowedIp[]
  ipAccessRequests IpAccessRequest[]
  userAdminAudits  UserAdminAudit[]

  categories     Category[]
  suppliers      Supplier[]
  supplierProviders SupplierProvider[]
  products       Product[]
  productInvoices ProductInvoice[]
  units          ProductUnit[]
  requests       Request[]
  requestStatusAudits RequestStatusAudit[]
  notifications Notification[]
  storedFiles    StoredFile[]
  stockMovements StockMovement[]

  publicRequests           PublicRequest[]
}

model User {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenantId String @db.Uuid
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  name         String
  email        String
  passwordHash String @map("password")
  username     String?

  isActive Boolean @default(true)

  // If true the user must change their password at next login
  mustChangePassword Boolean @default(false)

  // Optional association to a requesting service (servi√ßos requisitantes)
  requestingServiceId Int?
  requestingService   RequestingService? @relation(fields: [requestingServiceId], references: [id], onDelete: SetNull)

  createdByUserId String? @db.Uuid
  createdBy       User?   @relation("UserCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)
  createdUsers    User[]  @relation("UserCreatedBy")

  role UserRole @default(USER)

  acquiredUnits ProductUnit[] @relation("ProductUnitAcquiredBy")

  assignedUnits ProductUnit[] @relation("ProductUnitAssignedTo")

  requests Request[]

  createdRequests Request[] @relation("RequestCreatedBy")
  changedRequestStatusAudits RequestStatusAudit[] @relation("RequestStatusAuditChangedBy")
  notifications Notification[] @relation("NotificationRecipientUser")

  signedRequests Request[] @relation("RequestSignedBy")

  signedVoidedRequests Request[] @relation("RequestSignedVoidedBy")

  pickupRecordedRequests Request[] @relation("RequestPickupRecordedBy")

  pickupVoidedRequests Request[] @relation("RequestPickupVoidedBy")

  stockMovementsPerformed  StockMovement[] @relation("StockMovementPerformedBy")
  stockMovementsAssignedTo StockMovement[] @relation("StockMovementAssignedTo")

  createdAllowedIps       AllowedIp[]        @relation("AllowedIpCreatedBy")
  ipAccessRequests        IpAccessRequest[]  @relation("IpAccessRequestUser")
  reviewedIpAccessRequests IpAccessRequest[] @relation("IpAccessRequestReviewedBy")
  adminActions       UserAdminAudit[] @relation("UserAdminAuditActor")
  adminActionTargets UserAdminAudit[] @relation("UserAdminAuditTarget")

  submittedPublicRequests PublicRequest[] @relation("PublicRequestRequesterUser")
  handledPublicRequests           PublicRequest[]       @relation("PublicRequestHandledBy")

  @@unique([tenantId, email])
  @@unique([tenantId, username])
  @@index([tenantId])
  @@index([tenantId, createdAt(sort: Desc)])
  @@index([requestingServiceId])
}

model Category {
  id   String @id @default(uuid()) @db.Uuid
  name String

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  tenantId String @db.Uuid @map("userId")
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  products Product[]

  @@unique([tenantId, name])
  @@index([tenantId])
}

model Supplier {
  id   String @id @default(uuid()) @db.Uuid
  name String

  nif         String? @db.VarChar(30)
  email       String? @db.VarChar(255)
  phone       String? @db.VarChar(60)
  contactName String? @db.VarChar(120)
  address     String? @db.Text
  notes       String? @db.Text

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  tenantId String @db.Uuid @map("userId")
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  providers SupplierProvider[]
  products Product[]

  @@unique([tenantId, name])
  @@index([tenantId])
  @@index([isActive])
}

model SupplierProvider {
  id String @id @default(uuid()) @db.Uuid

  supplierId String @db.Uuid
  supplier   Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  name  String
  role  String? @db.VarChar(120)
  email String? @db.VarChar(255)
  phone String? @db.VarChar(60)
  notes String? @db.Text

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  tenantId String @db.Uuid @map("userId")
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, supplierId, name])
  @@index([tenantId])
  @@index([supplierId])
  @@index([isActive])
}

model Product {
  id          String   @id @default(uuid()) @db.Uuid
  name        String
  description String?
  sku         String   @unique
  price       Float
  quantity    BigInt
  status      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  tenantId   String @db.Uuid @map("userId")
  categoryId String @db.Uuid
  supplierId String @db.Uuid

  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  supplier Supplier @relation(fields: [supplierId], references: [id], onDelete: Restrict)

  invoices ProductInvoice[]

  units ProductUnit[]

  requestItems RequestItem[]

  publicRequestItems PublicRequestItem[]

  stockMovements StockMovement[]

  @@index([tenantId])
  @@index([categoryId])
  @@index([supplierId])
}

enum RequestStatus {
  DRAFT
  SUBMITTED
  APPROVED
  REJECTED
  FULFILLED
}

enum RequestPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum RequestGoodsType {
  MATERIALS_SERVICES
  WAREHOUSE_MATERIALS
  OTHER_PRODUCTS
}

enum PublicRequestStatus {
  RECEIVED
  ACCEPTED
  REJECTED
}

model Request {
  id         String        @id @default(uuid()) @db.Uuid
  status     RequestStatus @default(DRAFT)
  title      String?
  notes      String?
  gtmiYear   Int
  gtmiSeq    Int
  gtmiNumber String

  requestedAt DateTime @default(now())
  priority    RequestPriority @default(NORMAL)
  dueAt       DateTime?

  requestingService    String?
  requestingServiceId  Int?
  requestingServiceRef RequestingService? @relation(fields: [requestingServiceId], references: [id], onDelete: SetNull)
  requesterName        String?
  requesterEmployeeNo  String?
  deliveryLocation     String?
  expectedDeliveryFrom DateTime?
  expectedDeliveryTo   DateTime?

  goodsTypes RequestGoodsType[] @default([])

  supplierOption1 String?
  supplierOption2 String?
  supplierOption3 String?

  signedAt       DateTime?
  signedByName   String?
  signedByTitle  String?
  signedByUserId String? @db.Uuid
  signedBy       User?   @relation("RequestSignedBy", fields: [signedByUserId], references: [id], onDelete: SetNull)

  signedIp        String?
  signedUserAgent String?

  signedVoidedAt       DateTime?
  signedVoidedReason   String?
  signedVoidedByUserId String? @db.Uuid
  signedVoidedBy       User?   @relation("RequestSignedVoidedBy", fields: [signedVoidedByUserId], references: [id], onDelete: SetNull)

  pickupSignedAt           DateTime?
  pickupSignedByName       String?
  pickupSignedByTitle      String?
  pickupSignatureDataUrl   String?  @db.Text

  pickupSignedIp        String?
  pickupSignedUserAgent String?

  pickupRecordedByUserId String? @db.Uuid
  pickupRecordedBy       User?   @relation("RequestPickupRecordedBy", fields: [pickupRecordedByUserId], references: [id], onDelete: SetNull)

  pickupVoidedAt       DateTime?
  pickupVoidedReason   String?
  pickupVoidedByUserId String? @db.Uuid
  pickupVoidedBy       User?   @relation("RequestPickupVoidedBy", fields: [pickupVoidedByUserId], references: [id], onDelete: SetNull)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @default(now()) @updatedAt

  tenantId String @db.Uuid
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Who the request is for (requester/owner)
  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Who created the request (can be ADMIN acting on behalf)
  createdByUserId String @db.Uuid
  createdBy       User   @relation("RequestCreatedBy", fields: [createdByUserId], references: [id], onDelete: Restrict)

  items RequestItem[]

  invoices ProductInvoice[]

  files StoredFile[]

  stockMovements StockMovement[]

  acceptedFromPublicRequests PublicRequest[] @relation("PublicRequestAcceptedRequest")
  statusAudits RequestStatusAudit[]
  notifications Notification[]

  @@unique([tenantId, gtmiNumber])
  @@unique([tenantId, gtmiYear, gtmiSeq])
  @@index([tenantId])
  @@index([userId])
  @@index([createdByUserId])
  @@index([status])
  @@index([requestedAt])
  @@index([signedAt])
  @@index([signedByUserId])
  @@index([signedVoidedAt])
  @@index([signedVoidedByUserId])
  @@index([pickupSignedAt])
  @@index([pickupRecordedByUserId])
  @@index([pickupVoidedAt])
  @@index([pickupVoidedByUserId])
  @@index([requestingServiceId])
  @@index([priority])
  @@index([dueAt])
}

model RequestItem {
  id          String   @id @default(uuid()) @db.Uuid
  quantity    BigInt
  notes       String?
  unit        String?
  reference   String?
  destination String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  requestId String  @db.Uuid
  request   Request @relation(fields: [requestId], references: [id], onDelete: Cascade)

  productId String  @db.Uuid
  product   Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@index([requestId])
  @@index([productId])
}

model RequestingService {
  id         Int     @id
  codigo     String  @db.VarChar(10)
  designacao String
  ativo      Boolean @default(true)

  // Users optionally belong to a requesting service
  users User[]

  requests Request[]
  invoices ProductInvoice[]

  publicRequests           PublicRequest[]

  @@unique([codigo])
  @@index([ativo])
  @@map("servicos_requisitantes")
}

model PublicRequest {
  id        String             @id @default(uuid()) @db.Uuid
  createdAt DateTime           @default(now())
  updatedAt DateTime           @default(now()) @updatedAt

  status PublicRequestStatus @default(RECEIVED)

  tenantId String @db.Uuid
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  requestingServiceId Int
  requestingService   RequestingService @relation(fields: [requestingServiceId], references: [id], onDelete: Restrict)

  requesterName String
  requesterUserId String? @db.Uuid
  requesterUser   User? @relation("PublicRequestRequesterUser", fields: [requesterUserId], references: [id], onDelete: SetNull)
  requesterIp   String?

  deliveryLocation String?

  title String?
  notes String?

  handledAt       DateTime?
  handledNote     String?
  handledByUserId String? @db.Uuid
  handledBy       User?   @relation("PublicRequestHandledBy", fields: [handledByUserId], references: [id], onDelete: SetNull)

  acceptedRequestId String? @db.Uuid
  acceptedRequest   Request? @relation("PublicRequestAcceptedRequest", fields: [acceptedRequestId], references: [id], onDelete: SetNull)

  items PublicRequestItem[]

  @@index([tenantId])
  @@index([requestingServiceId])
  @@index([requesterUserId])
  @@index([status])
  @@index([createdAt])
}

model PublicRequestItem {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())

  publicRequestId String @db.Uuid
  publicRequest   PublicRequest @relation(fields: [publicRequestId], references: [id], onDelete: Cascade)

  productId String  @db.Uuid
  product   Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  quantity BigInt
  notes    String?
  unit     String?

  @@index([publicRequestId])
  @@index([productId])
}

model ProductInvoice {
  id            String   @id @default(uuid()) @db.Uuid
  invoiceNumber String
  reqNumber     String?
  reqDate       DateTime?
  issuedAt      DateTime @default(now())
  quantity      BigInt
  unitPrice     Float
  notes         String?

  requestingServiceId Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  tenantId  String @db.Uuid @map("userId")
  productId String @db.Uuid

  requestId String? @db.Uuid

  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  request Request? @relation(fields: [requestId], references: [id], onDelete: SetNull)

  requestingService RequestingService? @relation(fields: [requestingServiceId], references: [id], onDelete: SetNull)

  files StoredFile[]

  units ProductUnit[]

  stockMovements StockMovement[]

  @@unique([tenantId, invoiceNumber])
  @@index([tenantId])
  @@index([productId])
  @@index([requestId])
  @@index([requestingServiceId])
}

enum ProductUnitStatus {
  IN_STOCK
  ACQUIRED
  IN_REPAIR
  SCRAPPED
  LOST
}

model ProductUnit {
  id     String            @id @default(uuid()) @db.Uuid
  code   String            @unique
  status ProductUnitStatus @default(IN_STOCK)

  // Optional identification fields per unit
  serialNumber String?
  partNumber   String?
  assetTag     String?
  notes        String?

  createdAt  DateTime  @default(now())
  acquiredAt DateTime?

  tenantId String @db.Uuid @map("userId")
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  productId String  @db.Uuid
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  invoiceId String?         @db.Uuid
  invoice   ProductInvoice? @relation(fields: [invoiceId], references: [id], onDelete: SetNull)

  acquiredByUserId String? @db.Uuid
  acquiredBy       User?   @relation("ProductUnitAcquiredBy", fields: [acquiredByUserId], references: [id], onDelete: SetNull)

  // Optional assignment metadata for OUT movements
  assignedToUserId String? @db.Uuid
  assignedTo       User?   @relation("ProductUnitAssignedTo", fields: [assignedToUserId], references: [id], onDelete: SetNull)

  acquiredReason String?
  costCenter     String?
  acquiredNotes  String?

  stockMovements StockMovement[]

  @@unique([tenantId, serialNumber])
  @@unique([tenantId, partNumber])
  @@unique([tenantId, assetTag])
  @@index([tenantId])
  @@index([productId])
  @@index([invoiceId])
  @@index([acquiredByUserId])
  @@index([assignedToUserId])
}

enum StockMovementType {
  IN
  OUT
  RETURN
  REPAIR_OUT
  REPAIR_IN
  SCRAP
  LOST
}

model StockMovement {
  id       String            @id @default(uuid()) @db.Uuid
  type     StockMovementType
  quantity BigInt

  reason     String?
  costCenter String?
  notes      String?

  createdAt DateTime @default(now())

  // Tenant/owner inventory
  tenantId String @db.Uuid @map("userId")
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  productId String  @db.Uuid
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  unitId String?      @db.Uuid
  unit   ProductUnit? @relation(fields: [unitId], references: [id], onDelete: SetNull)

  invoiceId String?         @db.Uuid
  invoice   ProductInvoice? @relation(fields: [invoiceId], references: [id], onDelete: SetNull)

  requestId String?  @db.Uuid
  request   Request? @relation(fields: [requestId], references: [id], onDelete: SetNull)

  performedByUserId String? @db.Uuid
  performedBy       User?   @relation("StockMovementPerformedBy", fields: [performedByUserId], references: [id], onDelete: SetNull)

  assignedToUserId String? @db.Uuid
  assignedTo       User?   @relation("StockMovementAssignedTo", fields: [assignedToUserId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([productId])
  @@index([unitId])
  @@index([invoiceId])
  @@index([requestId])
  @@index([performedByUserId])
  @@index([assignedToUserId])
  @@index([createdAt])
}

enum StorageKind {
  INVOICE
  REQUEST
  DOCUMENT
  OTHER
}

model StoredFile {
  id           String      @id @default(uuid()) @db.Uuid
  kind         StorageKind
  originalName String
  fileName     String
  mimeType     String
  sizeBytes    Int
  storagePath  String

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  tenantId String @db.Uuid @map("userId")
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // optional links
  invoiceId String?         @db.Uuid
  invoice   ProductInvoice? @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  requestId String?  @db.Uuid
  request   Request? @relation(fields: [requestId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([kind])
  @@index([invoiceId])
  @@index([requestId])
}

model AllowedIp {
  id       String  @id @default(uuid()) @db.Uuid
  tenantId String  @db.Uuid
  tenant   Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  ipOrCidr String
  isActive Boolean @default(true)
  note     String?
  expiresAt DateTime?

  createdAt       DateTime @default(now())
  createdByUserId String?  @db.Uuid
  createdBy       User?    @relation("AllowedIpCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([isActive])
  @@index([expiresAt])
}

model IpAccessRequest {
  id       String                @id @default(uuid()) @db.Uuid
  tenantId String                @db.Uuid
  tenant   Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  userId String? @db.Uuid
  user   User?   @relation("IpAccessRequestUser", fields: [userId], references: [id], onDelete: SetNull)

  email     String
  ip        String
  userAgent String?

  status IpAccessRequestStatus @default(PENDING)

  createdAt  DateTime  @default(now())
  reviewedAt DateTime?

  reviewedByUserId String? @db.Uuid
  reviewedBy       User?   @relation("IpAccessRequestReviewedBy", fields: [reviewedByUserId], references: [id], onDelete: SetNull)

  note String?

  @@index([tenantId])
  @@index([status])
  @@index([createdAt])
  @@index([reviewedAt])
}

model UserAdminAudit {
  id        String   @id @default(uuid()) @db.Uuid
  action    String   @db.VarChar(80)
  targetType String  @db.VarChar(40) @default("USER")
  note      String?
  payload   Json?
  createdAt DateTime @default(now())

  tenantId String @db.Uuid
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  actorUserId String? @db.Uuid
  actor       User?   @relation("UserAdminAuditActor", fields: [actorUserId], references: [id], onDelete: SetNull)

  targetUserId String? @db.Uuid
  targetUser   User?   @relation("UserAdminAuditTarget", fields: [targetUserId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([createdAt])
  @@index([action])
  @@index([actorUserId])
  @@index([targetUserId])
}

enum NotificationKind {
  REQUEST_CREATED
  REQUEST_STATUS_CHANGED
  REQUEST_UPDATED
  PUBLIC_REQUEST_RECEIVED
  PUBLIC_REQUEST_ACCEPTED
  PUBLIC_REQUEST_REJECTED
  SECURITY_ALERT
  STORAGE_ALERT
}

model Notification {
  id        String   @id @default(uuid()) @db.Uuid
  kind      NotificationKind
  title     String
  message   String
  data      Json?
  createdAt DateTime @default(now())
  readAt    DateTime?

  tenantId String @db.Uuid
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  recipientRole   UserRole?
  recipientUserId String? @db.Uuid
  recipientUser   User?   @relation("NotificationRecipientUser", fields: [recipientUserId], references: [id], onDelete: Cascade)

  requestId String? @db.Uuid
  request   Request? @relation(fields: [requestId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([createdAt])
  @@index([readAt])
  @@index([recipientRole])
  @@index([recipientUserId])
  @@index([requestId])
}

model RequestStatusAudit {
  id             String        @id @default(uuid()) @db.Uuid
  fromStatus     RequestStatus?
  toStatus       RequestStatus
  note           String?
  source         String?
  createdAt      DateTime      @default(now())

  tenantId String @db.Uuid
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  requestId String  @db.Uuid
  request   Request @relation(fields: [requestId], references: [id], onDelete: Cascade)

  changedByUserId String? @db.Uuid
  changedBy       User?   @relation("RequestStatusAuditChangedBy", fields: [changedByUserId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([requestId])
  @@index([createdAt])
  @@index([toStatus])
  @@index([changedByUserId])
}

model RateLimitBucket {
  key     String   @id
  count   Int
  resetAt DateTime

  @@index([resetAt])
}

model AuthLockout {
  key          String   @id
  tenantId     String   @db.Uuid
  email        String
  ip           String
  failureCount Int
  lastFailedAt DateTime @default(now())
  lockedUntil  DateTime?

  @@index([tenantId])
  @@index([email])
  @@index([lockedUntil])
}
